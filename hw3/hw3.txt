The regional databases each contain 3 tables, one each for books, customers, and transactions. Each is composed of objects; Book objects, Customer objects, and Transactions objects. Each object contains fields with its information: for examples, every Book object contains String fields with the author’s name, the title, etc., and int field for the ISBN number, etc.
Each region contains a list of books for that region, a list of customers (identical to every other region’s list of customers), and a list containing transactions for that specific region (because it is easy to add items to lists, and books, customers, and transactions all need to be added to constantly).
Every time a customer is created, it is added to a central list of customers (in O(1) time), and then subsequently added to each region’s list of customers (each time being added to the end of the list, in O(1) time).
Each time a transaction occurs, it is added to the list of transactions in its region (adding to a list being O(1) time), because adding to lists is quick.
In order for a customer to access all his transactions’ information, it is necessary to traverse the entire list of transactions, checking each Transaction object’s Customer ID field, and adding them, one at a time, to a temporary list of transactions for that customer. This would take O(n) time. (To get info about one particular transaction, it would still take up to O(n) time.)
At 12 AM, each transaction list must be copied to a central array of transactions in the central database. Because we already know the number of transactions in each regional list, we know the length of the array to be created, and we simply need to copy all the transaction objects in once. Because no consistent adding or deleting is ever necessary to this data structure, it makes sense for it to be an array and not a list. Retrieval will be faster if it's an array, and retrieval is necessary often.
Product line managers must copy out from the central database of transactions daily all transactions which meet a certain criterion or have a certain tag. That tag being one of the fields of the transaction object, it will take O(n) time to search through all transactions in the central database and compile all transactions meeting the specified criterion. Adding them to a private temporary list will be O(1) time. It would be more difficult to add to this database if it was an array instead of a list.
Combining purchases from the private list into an aggregate customer will take O(n) time, and deleting them (once they're found and the pointers are noted) from the list will be O(1) - another reason this is a list and not an array (an array would make deleting nearly impossible).
After all the aggregate customers have been created from the private transaction DB, a list of 2D Components arrays can be created for of Aggregate Customer objects can be created, which holds Aggregate Customer ID and component transactions ID int fields. Retreival from the central DB is in O(1) time, as it is an array.
To go into details of an aggregate customer, it would take at most O(n) time to find the customer and return its details. Undoing an aggregate: retrieving from the central DB is fast because it's an array (O(1)), inserting into the private DB is fast because it's a list (O(1)), as is deleting the aggregate, because that's a list too (also O(1)).
Creating a summary/roll-up from the data will also take at most O(n) to find the item requested.